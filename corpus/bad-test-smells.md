Each section in this guide reflects an error that you might make writing a pgTAP test.
The section will include a description of the problem, an example of an incorrect test case (`bad example`), and an example of how to correctly write the test case (`good example`).
Use this knowledge when writing your own pgTAP tests.

# Validating Scalar Values in pgTAP

When comparing single values in pgTAP tests (like counts or IDs), you must use `select` syntax rather than `values` syntax. While `values(X::bigint)` is valid SQL in general, pgTAP's comparison functions require both sides to be proper SELECT queries.

bad example:

```
select results_eq(
    $$select count(*) from posts where created_by = auth.uid()$$,
    $$values(2::bigint)$$,
    'Post owner can view their posts'
);
```

good example:

```
select results_eq(
    $$select count(*) from posts where created_by = auth.uid()$$,
    $$select 2::bigint$$,
    'Post owner can view their posts'
);
```

# Using VALUES Syntax in pgTAP Result Comparisons

When comparing results in pgTAP tests, it's important to use the correct syntax for expected results. The `VALUES` syntax, while valid in general SQL, doesn't work properly with pgTAP's comparison functions.

bad example:

```sql
select results_eq(
    $$select count(*) from comments where post_id in (1, 2)$$,
    $$values(2::bigint)$$,
    'Post owner can read all comments on their posts'
);
```

good example:

```sql
select results_eq(
    $$select count(*) from comments where post_id in (1, 2)$$,
    $$select 2::bigint$$,
    'Post owner can read all comments on their posts'
);
```

# Only Testing RLS Policies (Omitting Table and Column Level Access Control in Tests)

You are only interested in testing RLS policies, not table and column level access control. As such, you should not write any tests assertions about table and column permissions.

bad example:

```
select tests.clear_authentication();
select throws_ok(
    $$insert into comments (post_id, content, created_by)
    values (1, 'Test comment', '00000000-0000-0000-0000-000000000000')$$,
    'permission denied for table comments',
    'Anonymous users cannot comment on posts'
);
```

good example:

```
select tests.clear_authentication();
select throws_ok(
    $$insert into comments (post_id, content, created_by)
    values (1, 'Test comment', '00000000-0000-0000-0000-000000000000')$$,
    'new row violates row-level security policy for table "comments"',
    'Anonymous users cannot comment on posts'
);
```

# Ensuring User is Provided in Queries when required

If a column references `auth.users(id), is not null, and has no default, then `auth.uid()` must be provided.

bad example:

```
create table posts (
    id bigint primary key generated by default as identity,
    title varchar(255) not null,
    content text not null,
    is_published boolean not null default false,
    created_by uuid not null references auth.users(id),
    created_at timestamp default current_timestamp
);

select tests.authenticate_as('post_owner');
insert into posts (title, content, is_published)
values
('Published Post', 'Published content', true),
('Draft Post', 'Draft content', false);
```

good example:

```
create table posts (
    id bigint primary key generated by default as identity,
    title varchar(255) not null,
    content text not null,
    is_published boolean not null default false,
    created_by uuid not null references auth.users(id),
    created_at timestamp default current_timestamp
);

select tests.authenticate_as('post_owner');
insert into posts (title, content, is_published, created_by)
values
('Published Post', 'Published content', true, auth.uid()),
('Draft Post', 'Draft content', false, auth.uid());
```

# Considering the Anon Role as Anonymous

The anon role is used to indicate anonymous users, and the tests must reflect as much.

bad example:

```
create policy "Anyone can read published posts"
    on posts for select to anon
    using (is_published);

select tests.clear_authentication();
select is_empty(
    $$select * from posts$$,
    'Anonymous users cannot view posts'
);
```

good example:

```
create policy "Anyone can read published posts"
    on posts for select to anon
    using (is_published);

select tests.clear_authentication();
select is_empty(
    $$select * from posts where is_published = false $$,
    'Anonymous users cannot view unpublished posts'
);
```

# Testing Row-Level Security (RLS) Policies for Different Users

When testing RLS policies, it's important to ensure that users can only access and modify data according to the policy rules. This includes verifying that users cannot view or modify data belonging to other users.

bad example:

```sql
create policy "Users can only view their own posts"
    on posts for select
    using (created_by = auth.uid());

select tests.authenticate_as('other_user');
select results_eq(
    $$select * from posts$$,
    $$select * from posts where created_by = auth.uid()$$,
    'Other users cannot view posts'
);
```

good example:

```sql
create policy "Users can only view their own posts"
    on posts for select
    using (created_by = auth.uid());

select tests.authenticate_as('other_user');
select is_empty(
    $$select * from posts where created_by != auth.uid()$$,
    'Other users cannot view posts belonging to others'
);

-- Also test insert attempts with different user_id
select throws_ok(
    $$insert into posts (title, content, created_by)
    values ('Test', 'Content', '00000000-0000-0000-0000-000000000000')$$,
    'new row violates row-level security policy for table "posts"',
    'Other users cannot create posts with different user id'
);
```

The bad example only tests if the query returns the expected rows but doesn't explicitly verify that other users' posts are inaccessible. The good example specifically checks that queries for other users' posts return empty results and that attempts to insert rows with different user IDs fail with the correct RLS policy violation.

# Testing Overlapping RLS Policies

When testing RLS policies, it's important to consider how multiple policies might interact. If you have policies that grant broader read access under certain conditions (like allowing anyone to read published posts), your tests need to account for this.

bad example:

```sql
-- Policy setup
create policy "Users can CRUD their own posts"
    on posts as permissive for all to authenticated
    using (created_by = auth.uid())
    with check (created_by = auth.uid());

create policy "Anyone can read published posts"
    on posts for select to authenticated, anon
    using (is_published);

-- Test (incorrect)
select tests.authenticate_as('other_user');
select is_empty(
    $$select * from posts$$,
    'Other users cannot view posts they do not own'
);
```

good example:

```sql
-- Policy setup (same as above)
create policy "Users can CRUD their own posts"
    on posts as permissive for all to authenticated
    using (created_by = auth.uid())
    with check (created_by = auth.uid());

create policy "Anyone can read published posts"
    on posts for select to authenticated, anon
    using (is_published);

-- Test (correct)
select tests.authenticate_as('other_user');
select is_empty(
    $$select * from posts where is_published = false$$,
    'Other users cannot view unpublished posts they do not own'
);
```

The bad example fails because it doesn't account for the "Anyone can read published posts" policy. The test incorrectly assumes that users should never see posts they don't own, but the policy actually allows them to see published posts regardless of ownership.

The good example specifically tests for unpublished posts, which correctly verifies that users can't see private content belonging to other users while still allowing the intended behavior of public access to published posts.

# Testing Database Constraints With RLS Enabled

When testing database constraints (like NOT NULL), it's important to remember that RLS policies are checked before constraints. This means you need to ensure your test has proper authentication to bypass RLS before you can effectively test the constraints.

bad example:

```sql
-- Test (incorrect)
select tests.clear_authentication();
select throws_ok(
    $$insert into comments (post_id, content, created_by)
    values (1, 'Test comment', null)$$,
    'null value in column "created_by" of relation "comments" violates not-null constraint',
    'created_by cannot be null'
);
```

good example:

```sql
-- Test (correct)
select tests.authenticate_as('post_owner');  -- Authenticate first to bypass RLS
select throws_ok(
    $$insert into comments (post_id, content, created_by)
    values (1, 'Test comment', null)$$,
    '23502',  -- Error code for not-null constraint violation
    'null value in column "created_by" of relation "comments" violates not-null constraint',
    'created_by cannot be null'
);
```

The bad example fails because the RLS policy blocks the insert before the database can check the not-null constraint. This results in an RLS violation error instead of the expected not-null constraint error.

The good example first authenticates as a user who has permission to insert comments, allowing the database to proceed to checking the constraints. This correctly triggers the not-null constraint violation we want to test.

Remember: Database operations are checked in this order:

1. Row Level Security (RLS)
2. Foreign Key Constraints
3. Check Constraints
4. Not Null Constraints

To test constraints, make sure you're properly authenticated to bypass RLS first.

# Testing User Impersonation Prevention

When testing RLS policies, it's important to verify that users cannot perform actions while impersonating other users. This is particularly important for insert/update operations where the `created_by` or `user_id` field is involved.

bad example:

```sql
select tests.authenticate_as('other_user');
select throws_ok(
    $$insert into posts (title, content, created_by)
    values ('Test Post', 'Content', '00000000-0000-0000-0000-000000000000')$$,
    'new row violates row-level security policy for table "posts"',
    'Other users cannot create posts as different user'
);
```

good example:

```sql
select tests.authenticate_as('other_user');
select throws_ok(
    $$insert into posts (title, content, created_by)
    values ('Test Post', 'Content', (select tests.get_supabase_uid('post_owner')))$$,
    'new row violates row-level security policy for table "posts"',
    'Other users cannot create posts as different user'
);
```

The bad example uses a hardcoded UUID which may not actually exist in the database. This could lead to the test failing for the wrong reason (like a foreign key constraint) before the RLS policy is even checked.

The good example:

1. Uses `tests.get_supabase_uid()` to get a real user's UUID
2. Tests a real impersonation attempt against an existing user
3. Ensures the RLS policy is what's preventing the operation, not some other constraint

Remember: When testing security policies, it's important to test with real data that would otherwise be valid if not for the security policy. This ensures you're testing the right thing.

# Testing RLS Policies Without Considering Default Access Patterns

When testing RLS policies, it's important to consider common access patterns and default behaviors. A common mistake is writing overly restrictive tests that don't account for intentionally public data.

bad example:

```sql
select tests.authenticate_as('other_user');
select is_empty(
    $$select * from posts$$,
    'Other users cannot view posts'
);
```

good example:

```sql
select tests.authenticate_as('other_user');
select is_empty(
    $$select * from posts where is_published = false$$,
    'Other users cannot view unpublished posts'
);

-- Optionally, also verify that published posts ARE visible
select isnt_empty(
    $$select * from posts where is_published = true$$,
    'Other users can view published posts'
);
```

The bad example fails because it assumes all posts should be invisible to other users. This conflicts with common access patterns where some data (like published posts) should be visible to all authenticated users.

The good example:

1. Specifically tests for restricted content (unpublished posts)
2. Can optionally verify that public content is accessible
3. Makes the test's intention clear through specific assertions

Remember: When testing RLS policies, consider:

- What data should be restricted
- What data should be public
- Whether your test accurately reflects these requirements

# Testing Anonymous Access Errors

When testing anonymous access restrictions, it's important to understand that RLS policies are checked before table-level permissions. When a policy is defined with `to authenticated`, anonymous users will receive an RLS violation error rather than a table permission error.

bad example:

```sql
select tests.clear_authentication();
select throws_ok(
    $$insert into comments (post_id, content, created_by)
    values (1, 'Test comment', '00000000-0000-0000-0000-000000000000')$$,
    'permission denied for table comments',
    'Anonymous users cannot comment'
);
```

good example:

```sql
select tests.clear_authentication();
select throws_ok(
    $$insert into comments (post_id, content, created_by)
    values (1, 'Test comment', '00000000-0000-0000-0000-000000000000')$$,
    'new row violates row-level security policy for table "comments"',
    'Anonymous users cannot comment'
);
```

The bad example expects a table-level permission error, but this is incorrect because:

1. RLS policies are checked before table permissions
2. When a policy specifies `to authenticated`, anonymous users will trigger an RLS violation
3. The error "new row violates row-level security policy" is the expected message in this case

Remember: Database operations are checked in this order:

1. Row Level Security (RLS)
2. Table Permissions
3. Foreign Key Constraints
4. Check Constraints
5. Not Null Constraints

# Testing Empty States Before Data Insertion

When testing database states, it's important to test empty states before inserting test data, especially when working with transactions and rollbacks. This ensures clean test conditions and prevents issues with constraints or leftover data.

bad example:

```sql
BEGIN;
select plan(2);

-- Create test data first
select tests.authenticate_as('post_owner');
insert into posts (title, content, is_published, created_by)
values ('Test Post', 'Content', true, auth.uid());

-- Try to test empty state by deleting data
delete from posts;
select is_empty(
    $$select * from posts$$,
    'Empty posts table returns no results'
);

select * from finish();
ROLLBACK;
```

good example:

```sql
BEGIN;
select plan(2);

-- Test empty state first
select tests.clear_authentication();
select is_empty(
    $$select * from posts$$,
    'Empty posts table returns no results'
);

-- Then create and test with data
select tests.authenticate_as('post_owner');
insert into posts (title, content, is_published, created_by)
values ('Test Post', 'Content', true, auth.uid());

select * from finish();
ROLLBACK;
```

# Testing RLS Policy Violations

When testing RLS policies that prevent certain actions, it's better to test that the action fails with the expected RLS policy violation rather than attempting the action and then checking if the data is visible.

bad example:

```sql
select tests.authenticate_as('post_viewer');
insert into comments (post_id, content, created_by) values
(999, 'Comment on non-existent post', auth.uid());

select is_empty(
    $$select * from comments where post_id = 999$$,
    'Comments on non-existent posts are not visible'
);
```

good example:

```sql
select tests.authenticate_as('post_viewer');
select throws_ok(
    $$insert into comments (post_id, content, created_by) values
    (999, 'Comment on non-existent post', auth.uid())$$,
    'new row violates row-level security policy for table "comments"',
    'Cannot comment on non-existent posts'
);
```

The bad example:

1. Attempts to insert data that should be prevented by RLS
2. If the insert succeeds (which it shouldn't), checks if the data is visible
3. Doesn't clearly indicate whether the protection is happening at insert time or select time

The good example:

1. Tests that the RLS policy prevents the invalid insert
2. Verifies the exact error message we expect
3. Makes it clear that the protection happens at insert time

Remember: When testing RLS policies that should prevent actions:

- Use `throws_ok()` to verify the action fails with the expected error
- Test the exact error message to ensure the failure is due to RLS and not some other constraint
- Make it clear in your test description what security measure you're testing

# Testing NOT NULL Constraints

When testing database operations, it's important to ensure that all columns with `NOT NULL` constraints are provided with valid non-null values, with special attention to boolean columns where NULL values are sometimes mistakenly used for testing edge cases.

bad example:

```sql
-- Attempting to insert NULL values
select tests.authenticate_as('post_owner');
insert into posts (title, content, is_published, created_by) values
('NULL Published Post', 'Content', null, auth.uid());

-- Missing required non-null column
insert into posts (title, content, is_published) values
('Missing User Post', 'Content', false);
```

good example:

```sql
select tests.authenticate_as('post_owner');

-- Test default values by omitting optional columns
insert into posts (title, content, created_by) values
('Default Post', 'Content', auth.uid());  -- Will use default value for is_published

-- Test explicit values including required columns
insert into posts (title, content, is_published, created_by) values
('Published Post', 'Content', true, auth.uid()),
('Unpublished Post', 'Content', false, auth.uid());
```

The bad example fails because:

1. NULL is not a valid value for a NOT NULL column
2. Testing with NULL doesn't actually test any meaningful edge case for a boolean

The good example:

1. Tests the default value behavior by omitting the column
2. Tests both true and false states explicitly
3. Respects the NOT NULL constraint while still covering all meaningful test cases

Remember: For boolean columns with NOT NULL constraints:

- Use the default value by omitting the column
- Test explicit true and false values
- Don't try to test NULL values as they aren't valid

# Testing RLS Policies with Redundant Anonymous Access Tests

When a policy specifies `to authenticated`, there's no need to explicitly test that anonymous users are blocked - this is handled automatically by PostgreSQL's RLS system.

bad example:

```sql
create policy "Users can read comments on posts they can view"
    on comments for select to authenticated
    using (
        exists (
            select 1 from posts
            where id = post_id
            and (is_published = true or created_by = auth.uid())
        )
    );

-- Redundant test
select tests.clear_authentication();
select throws_ok(
    $$select * from comments$$,
    'new row violates row-level security policy for table "comments"',
    'Anonymous users cannot read comments'
);
```

good example:

```sql
create policy "Users can read comments on posts they can view"
    on comments for select to authenticated
    using (
        exists (
            select 1 from posts
            where id = post_id
            and (is_published = true or created_by = auth.uid())
        )
    );

-- No test needed - PostgreSQL handles this automatically
```

The bad example includes a redundant test that checks if anonymous users are blocked from accessing the table. This test is unnecessary because:

1. When a policy specifies `to authenticated`, PostgreSQL automatically blocks anonymous access
2. This is core PostgreSQL functionality that doesn't need to be tested
3. Testing this adds noise to your test suite without providing additional value

Instead, focus your tests on the actual business logic in your RLS policies, such as ensuring authenticated users can only access appropriate records.
