Each section in this guide reflects an error that you might make writing a pgTAP test. The section will include a description of the problem, an example of an incorrect test case (`bad example`), and an example of how to correctly write the test case (`good example`).

# Validating Scalar Values in pgTAP

The syntax $$values(2::bigint)$$ is not valid for use in pgTAP, as pgTAP's functions like results_eq() expect SQL queries that return results that can be compared directly. The VALUES statement in SQL is valid in general, but it must be used correctly depending on the context.

For pgTAP, you would need to ensure that both the actual query and the expected result return comparable data. If you want to use a single value like 2::bigint, you should ensure the query returns a single-row result.

bad example:

```
select results_eq(
    $$select count(*) from posts where created_by = auth.uid()$$,
    $$values(2::bigint)$$,
    'Post owner can view their posts'
);
```

good example:

```
select results_eq(
    $$select count(*) from posts where created_by = auth.uid()$$,
    $$select (2::bigint)$$,
    'Post owner can view their posts'
);
```

# Only Testing RLS Policies (Omitting Table and Column Level Access Control in Tests)

You are only interested in testing RLS policies, not table and column level access control. As such, you should not write any tests assertions about table and column permissions.

bad example:

```
select tests.clear_authentication();
select throws_ok(
    $$insert into comments (post_id, content, created_by)
    values (1, 'Test comment', '00000000-0000-0000-0000-000000000000')$$,
    'permission denied for table comments',
    'Anonymous users cannot comment on posts'
);
```

good example:

```
select tests.clear_authentication();
select throws_ok(
    $$insert into comments (post_id, content, created_by)
    values (1, 'Test comment', '00000000-0000-0000-0000-000000000000')$$,
    'new row violates row-level security policy for table "comments"',
    'Anonymous users cannot comment on posts'
);
```

# Ensuring User is Provided in Queries when required

If a column references `auth.users(id), is not null, and has no default, then `auth.uid()` must be provided.

bad example:

```
create table posts (
    id bigint primary key generated by default as identity,
    title varchar(255) not null,
    content text not null,
    is_published boolean not null default false,
    created_by uuid not null references auth.users(id),
    created_at timestamp default current_timestamp
);

select tests.authenticate_as('post_owner');
insert into posts (title, content, is_published)
values
('Published Post', 'Published content', true),
('Draft Post', 'Draft content', false);
```

good example:

```
create table posts (
    id bigint primary key generated by default as identity,
    title varchar(255) not null,
    content text not null,
    is_published boolean not null default false,
    created_by uuid not null references auth.users(id),
    created_at timestamp default current_timestamp
);

select tests.authenticate_as('post_owner');
insert into posts (title, content, is_published, created_by)
values
('Published Post', 'Published content', true, auth.uid()),
('Draft Post', 'Draft content', false, auth.uid());
```

# Considering the Anon Role as Anonymous

The anon role is used to indicate anonymous users, and the tests must reflect as much.

bad example:

```
create policy "Anyone can read published posts"
    on posts for select to anon
    using (is_published);

select tests.clear_authentication();
select is_empty(
    $$select * from posts$$,
    'Anonymous users cannot view posts'
);
```

good example:

```
create policy "Anyone can read published posts"
    on posts for select to anon
    using (is_published);

select tests.clear_authentication();
select is_empty(
    $$select * from posts where is_published = false $$,
    'Anonymous users cannot view unpublished posts'
);
```
